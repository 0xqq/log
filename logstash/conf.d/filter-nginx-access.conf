filter {
  if [type] == "nginx_access" {
#      grok {
#        match => { "message" => "%{IPORHOST:clientip} - %{NOTSPACE:remote_user} \[%{HTTPDATE:timestamp}\] \"(?:%{WORD:method} %{NOTSPACE:request}(?: %{URIPROTO:proto}/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:status} (?:%{NUMBER:upstime}|-) %{NUMBER:reqtime} (?:%{NUMBER:size}|-) %{QS:referrer} %{QS:agent} %{QS:xforwardedfor} %{QS:reqbody} %{WORD:scheme} (?:%{IPV4:upstream}(:%{POSINT:port})?|-)" }
#        add_field => [ "received_at", "%{@timestamp}" ]
#        add_field => [ "received_from", "%{host}" ]
#      }
#
#      ruby {
#        init => "@kname = ['http_x_forwarded_for','time_local','request','status','body_bytes_sent','request_body','content_length','http_referer','http_user_agent','nuid','http_cookie','remote_addr','hostname','upstream_addr','upstream_response_time','request_time']"
#        code => "
#            new_event = LogStash::Event.new(Hash[@kname.zip(event.get('message').split('\t'))])
#            new_event.remove('@timestamp')
#            event.append(new_event)""
#        "
#      }

      json {
        source => "message"
      }

      mutate {
        convert => ["size", "integer", "responsetime", "float", "upstream_response_time", "float"]
      }

      if [http_cookie] {
        kv {
          prefix => "cookie_"
          source => "http_cookie"
          field_split => "; "
        }
      }
      if [request] {
          ruby {
            init => "@kname = ['method','uri','verb']"
            code => "
                new_event = LogStash::Event.new(Hash[@kname.zip(event.get('request').split(' '))])
                new_event.remove('@timestamp')
                event.append(new_event)""
            "
          }
          if [uri] {
              ruby {
                init => "@kname = ['url_path','url_args']"
                code => "
                    new_event = LogStash::Event.new(Hash[@kname.zip(event.get('uri').split('?'))])
                    new_event.remove('@timestamp')
                    event.append(new_event)""
                "
              }
              kv {
                prefix => "url_"
                source => "url_args"
                field_split => "& "
                remove_field => [ "url_args","uri","request" ]
              }
          }
      }
      mutate {
        convert => [
          "body_bytes_sent" , "integer",
          "content_length", "integer",
          "upstream_response_time", "float",
          "request_time", "float"
        ]
      }
      date {
        match => [ "time_local", "dd/MMM/yyyy:hh:mm:ss Z" ]
        locale => "en"
      }

  }
}